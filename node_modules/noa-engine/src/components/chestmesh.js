
var vec3 = require('gl-vec3')


export default function (noa) {
    return {

        name: 'chestmesh',

        order: 100,

        state: {
            mesh: null,
            offset: null,
			walkcycle:0,
			fired:false,
			walkcyle:0,
			headtimer:0,
			thirdp:false,
			moving:false,
			flying:false,
			dead:false,
			health:5,
			slabeffect:0,
			pos:null,
			body:null,
			particle:null,
			particle1:null,
			particle2:null,
			particlewater:null
			
			
			
        },


        onAdd: function (eid, state) {
			state.id=eid
            // implicitly assume there's already a position component
            var posDat = noa.ents.getPositionData(eid)
			state.pos=posDat.position
            if (state.mesh) {
                noa.rendering.addMeshToScene(state.mesh, false, posDat.position)
				noa.rendering.addMeshToScene(state.mesh._children[0], false, posDat.position)
				  noa.rendering.addMeshToScene(state.mesh._children[1], false, posDat.position)
				  
				  //var rad=BABYLON.Tools.ToDegrees(noa.camera.heading)	
				
				
				
			
				
				
				
            } else {
                throw new Error('Mesh component added without a mesh - probably a bug!')
            }
            if (!state.offset) state.offset = new vec3.create()

            // set mesh to correct position
            var rpos = posDat._renderPosition
            state.mesh.position.copyFromFloats(
                rpos[0] + state.offset[0],
                rpos[1] + state.offset[1],
                rpos[2] + state.offset[2])
				
				
				  var c=blocklook()
				  
				state.mesh.rotation.y=c
				
				
				function blocklook(){
	
	
	
	 var rad=BABYLON.Tools.ToDegrees(noa.camera.heading)	 
var viewdirection=0;
		 
		 if(rad>320  || rad <50){
	viewdirection=Math.PI
	
	//'north'
	
}
if(rad>130 && rad<230){
	viewdirection=0
	//'south'
	
}
if(rad>50 && rad<130){
	viewdirection=-Math.PI/2
	//'left'
	
	
}

if(rad>230 && rad<320){
	viewdirection=Math.PI/2
	//'right'
	
}
return viewdirection;

 }
        },


        onRemove: function (eid, state) {
            state.mesh.dispose()
        },



        renderSystem: function (dt, states) {
            // before render move each mesh to its render position, 
            // set by the physics engine or driving logic

            states.forEach(state => {
                var id = state.__id
			

                var rpos = noa.ents.getPositionData(id)._renderPosition
                state.mesh.position.copyFromFloats(
                    rpos[0] + state.offset[0],
                    rpos[1] + state.offset[1]+state.slabeffect,
                    rpos[2] + state.offset[2])
            })
        }
		
		


    }
}
