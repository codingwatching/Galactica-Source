'use strict'
//var audio2 = new Audio('Cow_idle2.oga');
var vec3 = require('gl-vec3')
var PF = require('pathfinding');
	
export default function (noa) {
    return {

        name: 'agroAI',

        order: 100,

        state: {
            mesh: null,
            offset: -0.5,
			startfall:0,
			endfall:0,
			walkcycle:0,
			health:31,
			audioz:null,
			direction:Math.random() * Math.PI * 2,
			lastJump:0.1,
			lifetime:6e4,
			rando:null,
			starttime:performance.now(),
			shouldRemove: !1 ,
			count:0,
			walkcycle:0,
			animate:false,
			flee:false,
			body:null,
			walking:500,
			position:null,
			path:null,
			playerpos:null,
			checkenemies:true,
			playerMesh:null,
			anglelook:0,
			rando:null,
			initialpos:null,
			particle:null,
			name:null,
			stopaction:null,
			leash:false,
			leashmesh:null,
			npcheight:5,
			up:0
			
        },


        onAdd: function (eid, state) {
			
			 state.mesh=noa.ents.getState(eid, noa.entities.names.entmesh).mesh
			 state.body = noa.ents.getPhysicsBody(eid)
			state.body.autoStep=true
			state.position=noa.ents.getState(eid, noa.entities.names.position).position
			
			state.playerpos=noa.ents.getState(noa.playerEntity, noa.entities.names.position).position
			state.playerMesh=noa.ents.getState(noa.playerEntity, noa.entities.names.mesh).mesh
		
			state.rando=[state.position[0]+Math.random()*10-5,state.position[1],state.position[2]+Math.random()*20-10]
			
			state.initialpos=state.position
			
			

			
			
			
			
			
			
        },


        onRemove: function (eid, state) {
             
			
        },



        renderSystem: function (dt, states) {
			
            // before render move each mesh to its render position, 
            // set by the physics engine or driving logic

            states.forEach(state => {
				
				
                var id = state.__id
				
				
				if(state.leash){
					
					if(state.leashmesh==null){
					var mat = new BABYLON.StandardMaterial("mat", scene);
mat.diffuseColor = BABYLON.Color3.White();
mat.ambientColor = BABYLON.Color3.White();
	mat.backFaceCulling = false;
	var bustex =new BABYLON.Texture(mod+"textures/block/dirt.png", scene, false, true, BABYLON.Texture.NEAREST_SAMPLINGMODE);
	mat.diffuseTexture=bustex
	var pos=noa.ents.getState(id, 'position').position
	var c=noa.ents.getState(noa.playerEntity, 'position').position
//	var c=	getdistance(pos,state.leash)
	state.leashmesh= BABYLON.MeshBuilder.CreatePlane('sprite-',{height:1,width:0.1,updatable:true}, scene)
	state.leashmesh.parent=state.mesh._children[0]
	state.leashmesh.material=mat
	state.leashmesh.position.x=state.mesh._children[0].position.x
	state.leashmesh.position.y=state.mesh._children[0].position.y+0.5
	state.leashmesh.position.z=state.mesh._children[0].position.z
	state.leashmesh.rotation.y=state.mesh._children[0].rotation.y
state.leashmesh.rotation.x=Math.PI/2
					}
					noa.rendering.addMeshToScene(state.leashmesh,false)
						function getdistance (playerMesh,playerMesh2){
                                        var dblDistanceX = playerMesh[0] - playerMesh2[0];
										var dblDistanceY =  playerMesh[1] - playerMesh2[1];
										var dblDistanceZ =  playerMesh[2] - playerMesh2[2];
										
								var realDistance=Math.sqrt((dblDistanceX * dblDistanceX) + (dblDistanceY * dblDistanceY) + (dblDistanceZ * dblDistanceZ));
								return  realDistance;
							}
							
							  function lookat(objecttarget,objectlooker){
	
						var direction=Math.atan2(objectlooker[1]-objecttarget[1],objectlooker[2]-objecttarget[2])
						return direction;
					}
					
					 function lookaty(objecttarget,objectlooker){
	
						var direction=Math.atan2(objecttarget.position.y,objectlooker.position.y)
						return direction;
					}
							
					
						
							
							//state.leash=null
							
							noa.on("tick", function(dt) {
								
								var posi=noa.ents.getState(id, 'position').position
	var ci=noa.ents.getState(noa.playerEntity, 'position').position
	var t=getdistance(posi,ci)
	
	//state.leashmesh.position.y=state.mesh._children[0].position.y+t
	state.leashmesh.material.diffuseTexture.vScale = t;
	//var headang=headerangle(ci,posi)
	

	//state.mesh._children[0].rotation.x=lerp(state.mesh._children[0].rotation.x,headang/Math.PI ,1);
	//state.leashmesh.rotation.x=0//-(Math.atan2(ci[1]-posi[1],ci[0]-posi[0],ci[2]-posi[2])) //+Math.PI/2
//	state.leashmesh.rotation.y=lookat(state.mesh,state.leashmesh)
	//state.leashmesh.rotation.x=lookaty(posi,ci)
	                               // state.leashmesh.position.y-=t
									state.leashmesh.scaling.y=t
	state.leashmesh.position.x=state.mesh._children[0].position.x
	state.leashmesh.position.y=state.mesh._children[0].position.y-1
	state.leashmesh.position.z=state.mesh._children[0].position.z-(t/2)+0.5
									
							});
							
							
							
				}
				
				
				
				state.count++
				
				//if(state.count>500){
				
					function headerangle(objectlooker,objecttarget){
						var headangle=(objectlooker[1]+0.6)-(objecttarget[1]-state.npcheight)
							return headangle;
                          }
				
				
					var dist=getdistance(state.mesh,state.playerMesh)
					
					
					if(dist>10){
						if(state.leashmesh ==true){
							
							state.leashmesh.dispose()
							state.leash=false;
						}
					}
				if(dist<6){
					
						var posi=noa.ents.getState(id, 'position').position
	var ci=noa.ents.getState(noa.playerEntity, 'position').position
						var headang=headerangle(ci,posi)
						//state.mesh._children[0].rotation.x=lerp(state.mesh._children[0].rotation.x,headang/Math.PI ,1);
				}else{
					state.mesh._children[0].rotation.x=0
				}
				if(dist<20 && dist>1){
					
					
					
					
				state.angle3=lookat(state.mesh,state.playerMesh)
						state.mesh.rotation.y=lerp(state.mesh.rotation.y,state.angle3,1)
						//state.mesh._children[0].rotation.y+=0.1
						
						/*var move = vec3.create()	
						vec3.lerp(move, state.position, state.playerpos, 1.0)			
						//var rot = noa.ents.getState(id, 'position').rotation
						noa.ents.setPosition(id, move)*/
					state.body.autoStep=true
					state.body.mass=0.8
					state.body.gravityMultiplier=1;
					
					if(state.body.resting[1]==-1){
					 var a = -5* Math.sin(state.angle3),
						c = -5* Math.cos(state.angle3);
						//noa.ents.getState(id,'stats').walking=state.name
						/*console.log('jake')
						
						state.mesh._children[5].rotation.x=Math.PI/2.5*/
						
						//state.body.friction=0+(dist/10);
						/*state.body.velocity[0]=a
						state.body.velocity[1]=0.6
						state.body.velocity[2]=c*/
						
						if(dist<4){
							  state.body.applyImpulse([0,1.5, 0])
							  noa.soundy('bark.ogg',0.5)
						}else{
							//state.up=0
						}
					
					
				    state.body.applyForce([a, state.up, c])
					
					if(Math.random()<0.005){
						 //state.body.applyImpulse([a, 8, c])
					}
					}
					
					
					/*state.body.velocity[0]=a
					state.body.velocity[1]=0.1
					state.body.velocity[2]=c*/
						/*var move = vec3.create()	
						vec3.lerp(move, state.position, state.playerpos, 1.0)			
						//var rot = noa.ents.getState(id, 'position').rotation
						noa.ents.setPosition(id, move)*/
					
					
					noa.ents.getState(id,'stats').walking=state.name
					
				}else if(dist>20){
					
						noa.ents.getState(id,'stats').walking='none'
					
					
					//noa.ents.setPosition(id, [state.playerpos[0],state.playerpos[1],state.playerpos[2]])
					
				
				
				
				
				}else{
					//state.mesh._children[0].rotation.y=0
					if(Math.random()<0.001){
						
						noa.soundy(orbsound)
					}
					
				
						noa.ents.getState(id,'stats').walking='none'
					
					state.body.velocity[0]=0
					state.body.velocity[1]=0
					state.body.velocity[2]=0
					
					
					state.rando=state.initialpos//[state.position[0]+Math.random()*10-5,state.position[1],state.position[2]+Math.random()*20-10]
				
				}
				

				  function looky(objectlooker,target){
					  
					  var direction=Math.atan2(objectlooker.position.x-target[0],objectlooker.position.z-target[2])
						return direction;
				  }
				   function lookatrandom(objectlooker,objecttarget){
	
						var direction=Math.atan2(objectlooker.position.x-state.rando[0],objectlooker.position.z-state.rando[2])
						return direction;
					}
				
				  if(state.walking<0){
					  state.walking=500
					
						noa.ents.getState(id,'stats').walking='none'
					
				  }
				  
				  function lookat(objectlooker,objecttarget){
	
						var direction=Math.atan2(objectlooker.position.x-objecttarget.position.x,objectlooker.position.z-objecttarget.position.z)
						return direction;
					}
				  
				  function getdistance (playerMesh,target){
                                        var dblDistanceX = playerMesh.position.x - target.position.x;
										var dblDistanceY = playerMesh.position.y - target.position.y;
										var dblDistanceZ = playerMesh.position.z - target.position.z;
										
								var realDistance=Math.sqrt((dblDistanceX * dblDistanceX) + (dblDistanceY * dblDistanceY) + (dblDistanceZ * dblDistanceZ));
								return  realDistance;
							}
							
							
							function getdistancerando (playerMesh,target){
                                        var dblDistanceX = playerMesh.position.x - target[0];
										var dblDistanceY = playerMesh.position.y - target[1];
										var dblDistanceZ = playerMesh.position.z - target[2];
										
								var realDistance=Math.sqrt((dblDistanceX * dblDistanceX) + (dblDistanceY * dblDistanceY) + (dblDistanceZ * dblDistanceZ));
								return  realDistance;
							}
							
							function lerp(start, end, amt){
				return (1-amt)*start+amt*end
			}
					
					
			
				
				
				
				
				
				
            })
        }


    }
}
