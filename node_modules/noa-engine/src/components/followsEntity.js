var vec3 = require('gl-vec3')


/*
 * Indicates that an entity should be moved to another entity's position each tick,
 * possibly by a fixed offset, and the same for renderPositions each render
 */

export default function (noa) {

    return {

        name: 'followsEntity',

        order: 50,

        state: {
            entity: 0 | 0,
            offset: null,
			mesh: null,
			name:null,
			body:null,
			go:false
			
			
        },

        onAdd: function (eid, state) {
            var off = vec3.create()
            state.offset = (state.offset) ? vec3.copy(off, state.offset) : off
            updatePosition(state)
            updateRenderPosition(state)
			console.log(state.body)
			
			
			if(state.body!==null){
			state.body.onStep=function bodyOnStep(){
					//console.log(impulse[1])
					   state.go=true
					setTimeout(function(){
						state.go=false
						}, 200);

	             }
			}
			if(state.name=='horse'){
				
				state.mesh=noa.ents.getState(eid, 'entmesh').mesh
				
				noa.ents.getState(noa.playerEntity, 'mesh').isRiding=true
							
				//noa.ents.getState(noa.playerEntity, 'mesh').wichrideable=eid
			}
			
			if(state.name=='hover'){
				
				//state.mesh=noa.ents.getState(eid, 'entmesh').mesh
				
				//noa.ents.getState(noa.playerEntity, 'mesh').isRiding=true
							noa.ents.getState(noa.playerEntity, 'mesh').slabeffect=1
				//noa.ents.getState(noa.playerEntity, 'mesh').wichrideable=eid
			}
			
		
			
			
        },

        onRemove: null,


        // on tick, copy over regular positions
        system: function followEntity(dt, states) {
            states.forEach(state => {//updatePosition(state))
			
				
					
					 var id = state.__id
					 
					 if(state.name=='hover'){
					 state.mesh.rotation.y=lerp(state.mesh.rotation.y,noa.camera.heading+Math.PI,0.1)
					 
					 
					          if(state.go){
								  console.log('cool')
								  
								   state.mesh.rotation.x=lerp(state.mesh.rotation.x,Math.PI/4,0.1)
							  }
							 else if(state.body.resting[1]!==-1){
								 state.mesh.rotation.x=lerp(state.mesh.rotation.x,-Math.PI/4,0.1)
							 }else{
								 state.mesh.rotation.x=lerp(state.mesh.rotation.x,0,0.1)
							 }
					 }
					 if(state.name=='horse'){
					var c=noa.ents.getState(noa.playerEntity, 'movement').running
					
			if(c){
		noa.ents.getState(id, 'stats').walking='horse'
							noa.ents.getState(noa.playerEntity, 'mesh').offset=[0,0,0]
							
							state.mesh.rotation.y=lerp(state.mesh.rotation.y,noa.camera.heading+Math.PI,0.1)
			}else{
				noa.ents.getState(id, 'stats').walking='none'
			}
				}
			
			 })
			
        },


        // on render, copy over render positions
        renderSystem: function followEntityMesh(dt, states) {
            states.forEach(state => updateRenderPosition(state))
        }
    }



    function updatePosition(state) {
        var id = state.__id
        var self = noa.ents.getPositionData(id)
        var other = noa.ents.getPositionData(state.entity)
		if(state.mesh!==null){
			
			state.mesh.rotation.y=lerp(state.mesh.rotation.y,noa.camera.heading+Math.PI,1)
	
		}
		if(state.name=='hover' && state.mesh!==null){
			
			state.mesh.rotation.y=lerp(state.mesh.rotation.y,noa.camera.heading+Math.PI,0.1)
	
		}
        if (!other) {
            return noa.ents.removeComponent(id, noa.ents.names.followsEntity)
        }
        vec3.add(self._localPosition, other._localPosition, state.offset)
    }
    
    function updateRenderPosition(state) {
        var id = state.__id
        var self = noa.ents.getPositionData(id)
        var other = noa.ents.getPositionData(state.entity)
        if (!other) {
            return noa.ents.removeComponent(id, noa.ents.names.followsEntity)
        }
        vec3.add(self._renderPosition, other._renderPosition, state.offset)
    }
	
	function lerp (start, end, amt){
				return (1-amt)*start+amt*end
			}

}
