
var vec3 = require('gl-vec3')


export default function (noa) {
    return {

        name: 'mesh',

        order: 100,

        state: {
            mesh: null,
            offset: null,
			walkcycle:0,
			fired:false,
			walkcyle:0,
			headtimer:0,
			thirdp:false,
			moving:false,
			flying:false,
			dead:false,
			slabeffect:0,
			pos:null,
			body:null,
			particle:null,
			particle1:null,
			particle2:null,
			particlewater:null,
			isRiding:false,
			wichrideable:null,
			bow:false,
			action:null,
			thisSocket:null,
			Onrail:false,
			rotangle:-Math.PI/2,
			hover:false,
			hitbox:null,
			sleeping:false,
			sitting:false,
			itemheld:null,
			chest:null
			
			
		
			
			
			
        },


        onAdd: function (eid, state) {
			state.id=eid
            // implicitly assume there's already a position component
            var posDat = noa.ents.getPositionData(eid)
			state.pos=posDat.position
            if (state.mesh) {
                noa.rendering.addMeshToScene(state.mesh, false, posDat.position)
				
				for (var i=0;i<state.mesh.getChildren().length;i++){
					noa.rendering.addMeshToScene(state.mesh._children[i], false, posDat.position)
				}
				
				 
					
			
				noa.camera.zoomDistance=10;
				state.body = noa.ents.getPhysicsBody(eid)
				state.body.autoStep=true
				
				state.body.onCollide=function bodyOnCollide(impulse){
					//console.log(impulse[1])
					if(impulse[1]>12){
playerhurt(state.body,noa,6,state.thisSocket)
					}

	  }
	  				state.body.onStep=function bodyOnStep(impulse){
	  console.log('boom')
	 state.body.applyImpulse([0,11,0])//
  }
	  
	  		/*	setInterval(function(){ 
		
		console.log('blah blah')
			
				//noa.setBlock(blockIDs.ice,[Math.floor(state.pos[0]),Math.floor(state.pos[1]-1),Math.floor(state.pos[2])])
				//state.thisSocket.emit('block-place', {position: [Math.floor(state.pos[0]),Math.floor(state.pos[1]-1),Math.floor(state.pos[2])],angle:'none',id:blockIDs.ice,info:'positionClose'})//
				
					}, 500);*/
				
				/*state.body.onStep=function bodyOnStep(impulse){
	  
	  console.log('stepping');
  }*/
				
				/*state.body.onCollide=function bodyOnCollide(impulse){
					
				if(state.body.inFluid==true){
					if(Math.random()<0.5){
					audio.play();
					}else{
						audio2.play();
					}
					state.particlewater.start()
					
					setTimeout(function(){ 
			
			           state.particlewater.stop()
					  

						}, 1000);	
						return;
				}
				var c=	noa.getBlock(Math.floor(state.pos[0]+state.body.resting[0]),Math.floor(state.pos[1]),Math.floor(state.pos[2]+state.body.resting[2]))
				
				var d=	noa.getBlock(Math.floor(state.pos[0]),Math.floor(state.pos[1]-1),Math.floor(state.pos[2]))
				if(c==21){
					state.body.applyImpulse([impulse[0]*2,6,impulse[2]*2])
				}
				if(d==21){
					state.body.applyImpulse([impulse[0]*2,6,impulse[2]*2])
				}
				
				//console.log(state.particle)
				if(state.particle!==null && state.particle1 !==null && state.particle2 !==null){
				//state.particle.start()
				
				state.particle.start()
				//state.particle1.start()
				//state.particle2.start()
						setTimeout(function(){ 
			
			
					   state.particle.stop()
					   //state.particle1.stop()
				       //state.particle2.stop()

						}, 1000);			
				}
				
	
			  
		  
		  
	  }*/
	/*  state.particle=makeparticle(mod+"textures/gui/ascii_sga.png")
	
	
	   state.particle1=makeparticle(mod+"textures/particle/generic_4.png")
	   state.particle2=makeparticle(mod+"textures/particle/generic_3.png")
	   state.particlewater=makeparticle(mod+"textures/particle/bubble.png")*/
	 
	 
				
				
				
				
            } else {
                throw new Error('Mesh component added without a mesh - probably a bug!')
            }
            if (!state.offset) state.offset = new vec3.create()

            // set mesh to correct position
            var rpos = posDat._renderPosition
            state.mesh.position.copyFromFloats(
                rpos[0] + state.offset[0],
                rpos[1] + state.offset[1],
                rpos[2] + state.offset[2])
        },


        onRemove: function (eid, state) {
            state.mesh.dispose()
        },



        renderSystem: function (dt, states) {
            // before render move each mesh to its render position, 
            // set by the physics engine or driving logic

            states.forEach(state => {
                var id = state.__id
				
				// state.body.mass=1
				if(state.sleeping){
					state.mesh._children[0].rotation.x=lerp(state.mesh._children[0].rotation.x,noa.camera.pitch-Math.PI/2,1)
					state.mesh._children[0].rotation.y=lerp(state.mesh._children[0].rotation.y,noa.camera.heading-state.mesh.rotation.y+Math.PI,1)
					state.mesh.rotation.x=-Math.PI/2;
					
					   var rpos = noa.ents.getPositionData(id)._renderPosition
                state.mesh.position.copyFromFloats(
                    rpos[0] + state.offset[0],
                    rpos[1] + state.offset[1]+0.5,
                    rpos[2] + state.offset[2])
           
		           state.body.mass=0
		               return;
				}
				
				if(state.sitting){
					
					state.mesh._children[0].rotation.x=lerp(state.mesh._children[0].rotation.x,noa.camera.pitch-Math.PI/2,1)
					state.mesh._children[0].rotation.y=lerp(state.mesh._children[0].rotation.y,noa.camera.heading-state.mesh.rotation.y+Math.PI,1)
					state.mesh.rotation.y=lerp(state.mesh.rotation.y,noa.camera.heading+Math.PI,1)
					
					//state.mesh._children[3].rotation.x=0//Math.PI/2
		//state.mesh._children[4].rotation.x=0//Math.PI/2
		
		//state.mesh._children[3].rotation.y=Math.PI/8
		//state.mesh._children[4].rotation.y=-Math.PI/8
					
					   var rpos = noa.ents.getPositionData(id)._renderPosition
                state.mesh.position.copyFromFloats(
                    rpos[0] + state.offset[0],
                    rpos[1] + state.offset[1],
                    rpos[2] + state.offset[2])
           
		           state.body.mass=0
		               return;
				}
				/*if(offmeshes.length>0){
					
					if(state.hitbox==null){
							return;
						}
					
					for (var i=0;i<offmeshes.length;i++){
						
						
				if (state.hitbox.intersectsMesh(offmeshes[i][1], false)) {
					var c=offmeshes[i][0]
					touches=true
					fakebb=[c[0]-state.pos[0],0,c[2]-state.pos[2]]
					
						//fakebb=[state.pos[0]-c[0],state.pos[1]-c[1],state.pos[2]-c[2]]
					
				
		
} 
				}
				}*/
				
		
				
				/*if(state.health<0){
					
					state.dead=true
					
				}
				if(state.dead==true){
						
												noa.entities.setPosition(noa.playerEntity,0,100,0);
									state.health=5;
									state.dead=false;
					}*/
					
				if(state.flying){
					state.mesh.rotation.x=Math.PI/2+noa.camera.pitch
				}
				
				
				var c=noa.ents.getState(noa.playerEntity, 'movement').running
				var d=noa.ents.getState(noa.playerEntity, 'movement').jumping
				
				
				
				if(!state.thirdp){
				
	/////camera angle			
	state.headtimer++
						if(state.headtimer>30){
							
							if(state.hover){
			state.mesh.rotation.y=lerp(state.mesh.rotation.y,noa.camera.heading+Math.PI/2,1)
		}else{
				state.mesh.rotation.y=lerp(state.mesh.rotation.y,noa.camera.heading,1)
		}
				state.headtimer=0;//
						}
		
		state.mesh._children[0].rotation.y=noa.camera.heading-state.mesh.rotation.y;
		
		if(!swimming){
	state.mesh._children[0].rotation.x=lerp(state.mesh._children[0].rotation.x,noa.camera.pitch+state.rotangle,1)
		}else{
			
			
			state.mesh._children[0].rotation.x=0//-Math.PI
			
		}
	
				}
				if(state.thirdp){
					 state.headtimer++
						if(state.headtimer>30){
				state.mesh.rotation.y=lerp(state.mesh.rotation.y,noa.camera.heading+Math.PI,1)
				state.headtimer=0;
						}
	
	
		state.mesh._children[0].rotation.x=lerp(state.mesh._children[0].rotation.x,-noa.camera.pitch,1)
		state.mesh._children[0].rotation.y=lerp(state.mesh._children[0].rotation.y,noa.camera.heading-state.mesh.rotation.y+Math.PI,1)
					
					
				}
				if(swimming){
					state.offset[1]=1
				}else{
					state.offset[1]=0
					
				}
				if(state.isRiding){
					
		state.mesh._children[3].rotation.x=-Math.PI/2
		state.mesh._children[4].rotation.x=-Math.PI/2
		
		state.mesh._children[3].rotation.z=-Math.PI/4
		state.mesh._children[4].rotation.z=Math.PI/4
		   var rpos = noa.ents.getPositionData(id)._renderPosition
                state.mesh.position.copyFromFloats(
                    rpos[0] + state.offset[0],
                    rpos[1] + state.offset[1]+state.slabeffect,
                    rpos[2] + state.offset[2])
           
		
		return;
				}
				
				if(state.hover){
					
		state.mesh._children[1].rotation.x= state.rotangle//-Math.PI/2//left leg 
		state.mesh._children[1].rotation.y=0//
		state.mesh._children[1].rotation.z=0
		
		
	
		state.mesh._children[2].rotation.x= state.rotangle//-Math.PI/2// right leg
		state.mesh._children[2].rotation.y= 0
		state.mesh._children[2].rotation.z=0
	
		state.mesh._children[3].rotation.x= state.rotangle//-Math.PI/2//right arm
		state.mesh._children[3].rotation.y= 0
		state.mesh._children[3].rotation.z=0
		
		state.mesh._children[4].rotation.x= state.rotangle//-Math.PI/2// left arm
		state.mesh._children[4].rotation.y= 0
		state.mesh._children[4].rotation.z=0
		   var rpos = noa.ents.getPositionData(id)._renderPosition
                state.mesh.position.copyFromFloats(
                    rpos[0] + state.offset[0],
                    rpos[1] + state.offset[1]+state.slabeffect,
                    rpos[2] + state.offset[2])
           
		
		return;
				}
				
				

	
					
					if(c || d || state.body.velocity[1]!==0){
						state.walkcycle++
						
						//var p=(noa.getBlock(Math.floor(state.pos[0]), Math.floor(state.pos[1])+1, Math.floor(state.pos[2]))==blockIDs['water'])
						if(swimming && !state.isRiding ){
								state.mesh._children[1].rotation.x=Math.PI
			state.mesh._children[2].rotation.x=-Math.PI 
			
			state.mesh._children[1].rotation.y=-0.7* Math.cos((0.32 * state.walkcycle) + (1.5 * Math.PI))+Math.PI/4;// left legMath.PI;
			state.mesh._children[2].rotation.y=-0.7* Math.cos((0.32 * state.walkcycle) + (0.5 * Math.PI))-Math.PI/4;
			
			state.mesh._children[1].rotation.z=1.0* Math.cos((0.32 * state.walkcycle) + (1.5 * Math.PI))+Math.PI/2;// left legMath.PI;
			state.mesh._children[2].rotation.z=1.0* Math.cos((0.32 * state.walkcycle) + (0.5 * Math.PI))-Math.PI/2;
							
						}
						else if(!state.fired & !state.bow ){
		state.mesh._children[1].rotation.x= 1.0* Math.cos((0.32 * state.walkcycle) + (0.5 * Math.PI));//left arm
		state.mesh._children[2].rotation.x= 1.0* Math.cos((0.32 * state.walkcycle) + (1.5 * Math.PI));
		//state.mesh._children[1].rotation.y = -1.0* Math.cos((0.32 * state.walkcycle) + (0.5 * Math.PI))+Math.PI/2;//left arm
		}
		
		else if(state.bow ){
			
			state.mesh._children[1].rotation.x= -Math.PI/2;
			state.mesh._children[2].rotation.x=- Math.PI/2;
		}else{
		state.mesh._children[2].rotation.x= 1.0* Math.cos((0.32 * state.walkcycle) + (1.5 * Math.PI))+state.rotangle;// right arm
		//state.mesh._children[2].rotation.y= -1.0* Math.cos((0.32 * state.walkcycle) + (1.5 * Math.PI))+Math.PI/2;// right arm
		
		}
		
	
		state.mesh._children[3].rotation.x= 1.0* Math.cos((0.32 * state.walkcycle) + (0.5 * Math.PI))+state.rotangle;//right leg
		
		state.mesh._children[4].rotation.x= 1.0* Math.cos((0.32 * state.walkcycle) + (1.5 * Math.PI))+state.rotangle;// left leg
		
						
					}else{
							if(!state.fired ){
								
		state.mesh._children[1].rotation.x= state.rotangle//-Math.PI/2//left leg 
		state.mesh._children[1].rotation.y=0//
		state.mesh._children[1].rotation.z=0
		
		}
		state.mesh.rotation.x=0;
		state.mesh._children[2].rotation.x= state.rotangle//-Math.PI/2// right leg
		state.mesh._children[2].rotation.y= 0
		state.mesh._children[2].rotation.z=0
	
		state.mesh._children[3].rotation.x= state.rotangle//-Math.PI/2//right arm
		state.mesh._children[3].rotation.y= 0
		state.mesh._children[3].rotation.z=0
		
		state.mesh._children[4].rotation.x= state.rotangle//-Math.PI/2// left arm
		state.mesh._children[4].rotation.y= 0
		state.mesh._children[4].rotation.z=0
						
						if(hand!==null){
						hand.rotation.z=0	
							hand.rotation.y=0
						}
						
					}
					
				
	
	
	if(state.fired ){
					state.walkcycle+=1;
										   var dblWeapon=0.47 * Math.PI;
											var dblProgress = 1.0 - (1 / 0.5);
											if (dblProgress < 0.3) {
												dblProgress = (dblProgress - 0.0) / 0.3;
												dblWeapon = (0.47 * Math.PI) + (dblProgress * 0.5 * Math.PI);
											} else if (dblProgress < 0.7) {
												dblProgress = (dblProgress - 0.3) / 0.4;
												dblWeapon = (0.97 * Math.PI) - (dblProgress * 1.0 * Math.PI);
											} else if (dblProgress < 1.0) {
												dblProgress = (dblProgress - 0.7) / 0.3;
												dblWeapon = (-0.03 * Math.PI) + (dblProgress * 0.5 * Math.PI);
											}
											
												if(!state.bow){
													state.mesh._children[1].rotation.x=0.5* Math.cos((0.16 * dblWeapon * state.walkcycle)) - Math.PI/2;
													
													state.mesh._children[1].rotation.z=-0.5* Math.cos((0.08 * dblWeapon * state.walkcycle)) ;
													
												}else{
													
													state.mesh._children[2].rotation.x=0.5* Math.cos((0.16 * dblWeapon * state.walkcycle)) - Math.PI/2;
													
													state.mesh._children[2].rotation.z=-0.8* Math.cos((0.08 * dblWeapon * state.walkcycle)) ;
													state.mesh._children[2].rotation.y=Math.PI/3 ;
												}
													
													if(hand!==null){
														//hand.rotation.x=0.5* Math.cos((0.16 * dblWeapon * state.walkcycle)) + Math.PI;
														hand.rotation.z=0.5* Math.cos((0.08 * dblWeapon * state.walkcycle)) ;
														hand.rotation.y=0.5* Math.cos((0.08 * dblWeapon * state.walkcycle)) ;
													}
					}
	
	function lerp (start, end, amt){
				return (1-amt)*start+amt*end
			}
				
				/////camera angle
				
				var slabtest=noa.getBlock(Math.floor(state.pos[0]), Math.floor(state.pos[1]-1), Math.floor(state.pos[2]))
				
				var firetest=noa.getBlock(Math.floor(state.pos[0]), Math.floor(state.pos[1]), Math.floor(state.pos[2]))
				
				
				
				if(blocks[slabtest]!==undefined){
					
					if(blocks[slabtest].name=='ice'){
						state.body.friction=0.05
					
					}else{
						state.body.friction=0.8
					}
					
					
					
					
					
					
			blocks[slabtest].data.slab ? state.slabeffect=-0.5 : state.slabeffect=0;
			noa.ents.getState(noa.playerEntity, 'shadow').offset=state.slabeffect
			
			
			
				}
				if(blocks[firetest]!==undefined){
					
					if(blocks[firetest].name=='fire'){
						playerhurt(state.body,noa,0.5,state.thisSocket)
						
						
					}
				}
				
				
				

                var rpos = noa.ents.getPositionData(id)._renderPosition
                state.mesh.position.copyFromFloats(
                    rpos[0] + state.offset[0],
                    rpos[1] + state.offset[1]+state.slabeffect,
                    rpos[2] + state.offset[2])
            })
        }
		
		


    }
}
var done=false


function playerhurt(body,noa,damage,socket){
	
	if(body.resting[1]<0){
						body.applyImpulse([0,3,0])
								if(noa.ents.getState(noa.playerEntity, 'stats').health>0){
									
									for(var i=0;i<damage;i++){
									if(noa.ents.getState(noa.playerEntity, 'stats').health %1){
									if(health>0){	
									health--
									}
									if(noa.ents.getState(noa.playerEntity, 'stats').health<1){
										if(!done){
										noa.playerdown(socket)
										//done=true
										}
										return;
									}
									
				
									
									//noa.soundy('/random/classic_hurt.ogg')
									}
									}
									noa.ents.getState(noa.playerEntity, 'stats').health-=damage
										
									noa.camera.heading+=0.1
									noa.camera.pitch+=0.1
									setTimeout(function(){ 
                                     noa.camera.heading-=0.1
									noa.camera.pitch-=0.1

									}, 500);
									
								}
						}
}



 function makeparticle(name){
	  var particleSystem = new BABYLON.ParticleSystem("particles", 2000, scene);
	  var c=new BABYLON.Texture(name, scene, false, true, BABYLON.Texture.NEAREST_SAMPLINGMODE);
    particleSystem.particleTexture= c
particleSystem.color1 = new BABYLON.Color4(1,0,0, 1.0);
particleSystem.color2 = new BABYLON.Color4(1,0,0, 1.0);
particleSystem.colorDead = new BABYLON.Color4(1,1,1, 1.0);

    // Position where the particles are emiited from
	var box=state.mesh._children[0]
	
	   particleSystem.isAnimationSheetEnabled = true;
	particleSystem.startSpriteCellID = 0;
                particleSystem.endSpriteCellID = 32;
                particleSystem.spriteCellHeight = 15;
               particleSystem.spriteCellWidth = 16;
                particleSystem.spriteCellLoop = true;
				 particleSystem.spriteCellChangeSpeed=0.01;
				particleSystem.spriteRandomStartCell=false;
           particleSystem.emitter =box
	       particleSystem.minSize =1//0.1
           particleSystem.maxSize =1//0.3
		   particleSystem.blendMode =BABYLON.ParticleSystem.BLENDMODE_STANDARD;
		  var matrixangle=noa.camera.getDirection()
		   particleSystem.direction1 = new BABYLON.Vector3(-matrixangle[0],0.2,-matrixangle[2]);
		   particleSystem.direction2 = new BABYLON.Vector3(-matrixangle[0],0.3,-matrixangle[2]);
		   particleSystem.minEmitPower = 1;
            particleSystem.maxEmitPower = 2;
            particleSystem.updateSpeed = 0.002
			 particleSystem.gravity = new BABYLON.Vector3(0,1, 0);
			 
	return particleSystem;
	
}
