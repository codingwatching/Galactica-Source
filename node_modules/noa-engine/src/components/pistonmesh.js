
var vec3 = require('gl-vec3')


export default function (noa) {
    return {

        name: 'pistonmesh',

        order: 100,

        state: {
            mesh: null,
            offset: [0,0.5,0],
			walkcycle:0,
			fired:false,
			walkcyle:0,
			headtimer:0,
			thirdp:false,
			moving:false,
			goal:0
			
			
        },


        onAdd: function (eid, state) {
			
            // implicitly assume there's already a position component
            var posDat = noa.ents.getPositionData(eid)
            if (state.mesh) {
                noa.rendering.addMeshToScene(state.mesh, false, posDat.position)
				 noa.rendering.addMeshToScene(state.mesh._children[0], false, posDat.position)
				 
				 
				 
			
			
				
					// noa.rendering.addMeshToScene(state.mesh._children[0], false, posDat.position)
				
				
				//var body = noa.ents.getPhysicsBody(eid)
            } else {
                throw new Error('Mesh component added without a mesh - probably a bug!')
            }
            if (!state.offset) state.offset = new vec3.create()

            // set mesh to correct position
            var rpos = posDat._renderPosition
            state.mesh.position.copyFromFloats(
                rpos[0] + state.offset[0],
                rpos[1] + state.offset[1],
                rpos[2] + state.offset[2])
				
				
				var scene=noa.rendering.getScene()
				
				
					 var animationBox = new BABYLON.Animation("movement", "position.z", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT,
		BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE)

	var keys = [];
	keys.push({
		frame: 0,
		value: 0.08
	});

	keys.push({
		frame: 20,
		value: 0.085
	})

	keys.push({
		frame: 40,
		value: 0.08
	})

	keys.push({
		frame: 60,
		value: 0.075
	})

	keys.push({
		frame: 80,
		value: 0.08
	})

	animationBox.setKeys(keys)

	state.mesh._children[0].animations.push(animationBox)
	scene.beginAnimation(state.mesh._children[0], 0, 100, true)
				
				
				
        },


        onRemove: function (eid, state) {
            state.mesh.dispose()
        },



        renderSystem: function (dt, states) {
            // before render move each mesh to its render position, 
            // set by the physics engine or driving logic

            states.forEach(state => {
                var id = state.__id
				
				state.goal+=0.1
				
				if(state.goal<2){
					
					state.mesh._children[0].position.y+=0.1
				}
				
			//state.walkcycle+=0.1
			
			//state.mesh._children[0].position.y+=Math.sin(state.walkcycle)*0.1

                var rpos = noa.ents.getPositionData(id)._renderPosition
                state.mesh.position.copyFromFloats(
                    rpos[0] + state.offset[0],
                    rpos[1] + state.offset[1],
                    rpos[2] + state.offset[2])
            })
        }
		
		


    }
}
