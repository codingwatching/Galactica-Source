
var vec3 = require('gl-vec3')


export default function (noa) {
    return {

        name: 'rotation',

        order: 100,

        state: {
            mesh: null,
            offset: null,
			walkcycle:0,
			fired:false,
			walkcyle:0,
			headtimer:0,
			thirdp:false,
			moving:false,
			flying:false,
			dead:false,
			slabeffect:0,
			pos:null,
			body:null,
			particle:null,
			particle1:null,
			particle2:null,
			particlewater:null,
			isRiding:false,
			wichrideable:null,
			bow:false,
			action:null,
			thisSocket:null,
			Onrail:false,
			rotangle:-Math.PI/2
		
			
			
			
        },


        onAdd: function (eid, state) {
			state.id=eid
            // implicitly assume there's already a position component
            var posDat = noa.ents.getPositionData(eid)
			state.pos=posDat.position
         
        },


        onRemove: function (eid, state) {
            state.mesh.dispose()
        },



        renderSystem: function (dt, states) {
            // before render move each mesh to its render position, 
            // set by the physics engine or driving logic

            states.forEach(state => {
                //var id = state.__id
				
				state.mesh.rotation.y+=0.01
				
				
				
            })
        }
		
		


    }
}
var done=false


function playerhurt(body,noa,damage,socket){
	
	if(body.resting[1]<0){
						body.applyImpulse([0,3,0])
								if(noa.ents.getState(noa.playerEntity, 'stats').health>0){
									
									for(var i=0;i<damage;i++){
									if(noa.ents.getState(noa.playerEntity, 'stats').health %1){
										
									console.log('health is:'+noa.ents.getState(noa.playerEntity, 'stats').health)
									var myobj = document.getElementById('hearts');
									if(noa.ents.getState(noa.playerEntity, 'stats').health<1){
										if(!done){
										noa.playerdown(socket)
										//done=true
										}
										return;
									}
									
				
									myobj.remove();
									noa.soundy('/random/classic_hurt.ogg')
									}
									}
									noa.ents.getState(noa.playerEntity, 'stats').health-=damage
										
									noa.camera.heading+=0.1
									noa.camera.pitch+=0.1
									setTimeout(function(){ 
                                     noa.camera.heading-=0.1
									noa.camera.pitch-=0.1

									}, 500);
									
								}
						}
}



 function makeparticle(name){
	  var particleSystem = new BABYLON.ParticleSystem("particles", 2000, scene);
	  var c=new BABYLON.Texture(name, scene, false, true, BABYLON.Texture.NEAREST_SAMPLINGMODE);
    particleSystem.particleTexture= c
particleSystem.color1 = new BABYLON.Color4(1,0,0, 1.0);
particleSystem.color2 = new BABYLON.Color4(1,0,0, 1.0);
particleSystem.colorDead = new BABYLON.Color4(1,1,1, 1.0);

    // Position where the particles are emiited from
	var box=state.mesh._children[0]
	
	   particleSystem.isAnimationSheetEnabled = true;
	particleSystem.startSpriteCellID = 0;
                particleSystem.endSpriteCellID = 32;
                particleSystem.spriteCellHeight = 15;
               particleSystem.spriteCellWidth = 16;
                particleSystem.spriteCellLoop = true;
				 particleSystem.spriteCellChangeSpeed=0.01;
				particleSystem.spriteRandomStartCell=false;
           particleSystem.emitter =box
	       particleSystem.minSize =1//0.1
           particleSystem.maxSize =1//0.3
		   particleSystem.blendMode =BABYLON.ParticleSystem.BLENDMODE_STANDARD;
		  var matrixangle=noa.camera.getDirection()
		   particleSystem.direction1 = new BABYLON.Vector3(-matrixangle[0],0.2,-matrixangle[2]);
		   particleSystem.direction2 = new BABYLON.Vector3(-matrixangle[0],0.3,-matrixangle[2]);
		   particleSystem.minEmitPower = 1;
            particleSystem.maxEmitPower = 2;
            particleSystem.updateSpeed = 0.002
			 particleSystem.gravity = new BABYLON.Vector3(0,1, 0);
			 
	return particleSystem;
	
}
